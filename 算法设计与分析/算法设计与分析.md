[TOC]



# 概要

## 计算程序 = 数据结构 + 算法

计算机程序可视为数据结构和算法的集成，这种集成体现为以下两方面的内容

**（1）对数据的描述** 数据是程序实现的基础，在程序中必须确定数据的类型及其组织形式，即数据结构。

**（2）对数据的具体操作 ** 这一具体操作过程，也就是算法。

## 算法特点

**（1）有穷性：**一个算法应该包括有限的操作步骤，而不可能是无限的

**（2）确定性：**算法中每一个步骤都应当是确定的

**（3）有零个或多个输入：**一个程序段输入是指在执行算法时需要从外界所获得的必要的数据信息

**（4）有一个或多个输出：**所有算法的目的是为了满足输出，也就是求解

**（5）有效性：**就一个算法而言，每一个步骤都应当有效地执行，并得到相应确定的结果

# 复杂度分析

## 直观定义

算法复杂度是算法运行所需要的计算机资源的量，需要时间资源的量称为**<u>时间复杂度</u>**，需要空间资源的量称为**<u>空间复杂度</u>**

- 时间复杂度和空间复杂度是只依赖于算法求解的<u>问题规模</u>和<u>算法输入</u>的函数

- N、I分别表示算法求解的问题规模和算法输入，则算法的时间复杂度*T*和空间复杂度*S*可以分别表示为：

  ```
  T = T(N,I)
  S = S(N,I)
  ```

时间复杂度不应该是在特定计算机上求解某一个输入实例所需要的运行时间,而应该是一个不依赖于**计算机配置**、**问题规模**和**输入实例**（影响算法执行时间的三大因素）的抽象表示

## 时间复杂度

###  大O的定义 *

设f(N)和g(N)是定义在正数集上的正函数，如果**存在**正的常数C和自然数$N_0$，使得当$N≥N_0$时有f(N) ≤Cg(N)，则称函数f(N)当N充分大时**上有界**，g(N)是f(N)的一个**上界**，记为**f(N)=O(g(N))**，即f(N)的阶不高于g(N)的阶。

- **不是直接比较**f(N)和g(N)

- **O**表示的只是一个充分大的**上界**

### 证明题

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209000050951.png" alt="image-20241209000050951"  />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209000210133.png" alt="image-20241209000210133"  />

### 运算法则

1) O(f)+O(g)=O(max(f,g))；
2) **O(f)+O(g)=O(f+g)；**
3) O(f)O(g)=O(f*g)；
4) 如果g(N)=O(f(N))，则O(f)+O(g)=O(f)；
5) O(Cf(N))=O(f(N))，其中C是一个正的常数；
6) f=O(f)

### 大O比率定理 *

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209000949726.png" alt="image-20241209000949726" style="zoom:80%;" />

### 定义补充 *

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209001118169.png" alt="image-20241209001118169" style="zoom:80%;" />

### 时间复杂度类别

- **多项式**复杂度算法：$O(n^c)$
-  **指数**复杂度算法：$O(C^n)$

$O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) <O(n^3)…O(C^n)< O(n!) < O(n^n)$

## 时间复杂度分析 *

### 非递归时间复杂度分析

1. **确定关键操作** 可以是高级程序设计语言中的赋值、比较、算术运算、逻辑运算、读写单个常量或单个变量等操作；也可以是由常数个基本操作构成的程序块。
2. **计算关键操作总的执行步数** 一般是**数列和**的形式
3. **求解其渐进阶**，并用**O(.)**表示

**实例**<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209002756185.png" alt="image-20241209002756185" style="zoom: 67%;" />

### 递归算法时间复杂度分析

1. **分析程序结构**：确定每一逻辑块的时间复杂性 **非递归的程序块**（或者子函数）用非递归方法分析其复杂性；**递归函数**的复杂性则根据据其输入规模递归地表示。
2. **构造复杂性函数的** **递推方程**
3. **求解递归方程和渐进阶**，并用**O(.)**表示

**实例1**<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209002858752.png" alt="image-20241209002858752" style="zoom: 67%;" />

**实例2**<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209002913412.png" alt="image-20241209002913412" style="zoom: 67%;" />

## 排序问题

### 排序问题的效率

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215000258595.png" alt="image-20241215000258595" style="zoom:80%;" />

### 排序运行实例

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215000331581.png" alt="image-20241215000331581" style="zoom: 67%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215000349370.png" alt="image-20241215000349370" style="zoom:67%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215000417407.png" alt="image-20241215000417407" style="zoom:67%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215000430982.png" alt="image-20241215000430982" style="zoom:67%;" />

# 枚举算法

## 基本思想

按照问题本身的性质，**一 一列举**出该问题所有可能的解，并在列举的过程中，**逐一检验**每个可能解是否是问题的真正解。若是则采纳这个解；否则抛弃它

- **不能遗漏**、**不要重复**
- **解的高准确性和全面性**
- **实现简单，枚举算法通过循环来逐一列举和验证可能解**
- **效率提升空间比较大**

## 枚举三步骤

1. **确定枚举对象** 枚举对象也可以理解为是问题解的表达形式，一般需要用若干参数来描述
   - 参数之间需要**相互独立**，而且，参数数目越少，问题解的搜索空间的维度也相应地小；
   - 每个参数的**取值范围**越小，问题解的搜索空间也越小。
2. **逐一列举可能解** 根据枚举对象的参数构造循环，一一列举其表达式的每一种取值情况。
3. **逐一验证可能解** 根据问题解的要求，一一验证枚举对象表达式的每一个取值，如果满足条件，则采纳它，否则，抛弃之。

## 一般化最优问题

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209011513636.png" alt="image-20241209011513636"  />

# 分治算法

## 基本思想

- **分：** <u>将大规模的原问题分割成 k 个更小规模的子问题</u>，如果子问题的规模仍然不够小，则再划分为 k 个子问题，如此**递归地**进行下去，直到子问题规模足够小（基础问题），很容易求出其解为止。

- **治：** 求解规模足够小的子问题。（<u>递归处理流程</u>）

- **合：** <u>将求出的小规模的问题的解合并为一个更大规模的问题的解</u>，自底向上逐步求出原来问题的解。

## 基本原理

### 伪代码及其解释

```伪代码
if ( |P| <= n0) adhoc(P); //递归出口，用特定程序解决基础问题
divide P into smaller subinstances P1,P2,...,Pk；//分解出子问题
for (i = 1, i <= k, i++)
    yi = divide-and-conquer(Pi); //递归求解各子问题
return merge(y1,...,yk); //将各子问题的解合并为原问题的解 }
```

- **|P|表示问题P的规模**：$𝑛_0$是一个预先定义的阈值，表示当问题P的规模不超过$𝑛_0$时，**问题已容易求解**，不必要继续分解和递归调用。

- **adhoc(P)**：分治算法中的子程序，对应**治过程**，一般是常数时间复杂度的子函数或者子过程。

- **划分策略的设计：**把原问题P**分解成k个规模较小的子问题**，往往遵循两个原则：
  -  **平衡子问题原则**，分割出的k个子问题其规模最好大致相当；
  
  -  **独立子问题原则**，分割出的k个子问题之间重叠越少越好，最好k个子问题是相互独立，不存在重叠子问题。
  
- **merge合并子程序**：把k个子问题的解合并得到原问题的解。

### 时间复杂度分析

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209012540246.png" alt="image-20241209012540246"  />

------

![image-20241209150015336](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209150015336.png)

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209150043387.png" alt="image-20241209150043387" style="zoom:67%;" />

## 划分策略

1. **黑盒划分策略：**此类方法根据问题的规模对原问题进行划分，而不考虑划分对象的属性值
2. **白盒划分策略：**此方法根据划分对象的特定属性值（也称之为参照值）把对象集合划分为若干个子集
3. **减治策略：**对于某些问题，根据白盒划分策略分割的部分子集与原问题无关或者与其他子问题等同，而不需要求解，可以认为减少了求解空间，称之为**减治策略**。

## 课堂典型例题 *

### 矩阵乘法：Strassen算法

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209013848619.png" alt="image-20241209013848619" style="zoom:67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209013932922.png" alt="image-20241209013932922" style="zoom: 67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209013945114.png" alt="image-20241209013945114" style="zoom: 67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209014011526.png" alt="image-20241209014011526" style="zoom: 67%;" />

**时间复杂性：**$O(n^{log_27})$

###  归并排序——黑盒划分典型问题

**处理思想：**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209014155726.png" alt="image-20241209014155726" style="zoom:150%;" />

**处理流程：**

![image-20241209014317452](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209014317452.png)

**代码实现：**
时间复杂度：$O(nlogn)$ $=$  $logn$（递归）* $O(n)$（归并，线性扫描）

```c++
算法：Merge
输入：数组 A，临时数组 temp，区间起点 l，中点 mid，终点 r
输出：数组 A 在区间 [l..r] 内有序

1. i ← l
2. j ← mid + 1
3. k ← l
4. while i ≤ mid and j ≤ r do
5.     if A[i] > A[j] then
6.         temp[k] ← A[j]
7.         j ← j + 1
8.     else
9.         temp[k] ← A[i]
10.        i ← i + 1
11.    k ← k + 1
12. while i ≤ mid do
13.    temp[k] ← A[i]
14.    i ← i + 1
15.    k ← k + 1
16. while j ≤ r do
17.    temp[k] ← A[j]
18.    j ← j + 1
19.    k ← k + 1
20. for i ← l to r do
21.    A[i] ← temp[i]

算法：MergeSort
输入：数组 A，临时数组 temp，区间起点 l，终点 r
输出：数组 A 在区间 [l..r] 内有序

1. if l < r then
2.    mid ← l + (r - l) / 2
3.    MergeSort(A, temp, l, mid)
4.    MergeSort(A, temp, mid + 1, r)
5.    Merge(A, temp, l, mid, r)
```



### 逆序对问题——黑盒划分典型问题

**处理思想：**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209014442330.png" alt="image-20241209014442330" style="zoom:150%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209015213733.png" alt="image-20241209015213733" style="zoom:150%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209015259530.png" alt="image-20241209015259530" style="zoom: 80%;" />

------

![image-20241209015326610](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209015326610.png)

**处理流程：** <img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209015530613.png" alt="image-20241209015530613"  />

**代码实现：**

时间复杂度：$O(nlogn)$ $=$  $logn$（递归）* $O(n)$（归并，线性扫描）

```c++
算法：Merge
输入：数组 A，临时数组 temp，区间起点 l，中点 mid，终点 r
输出：区间 [l..r] 内合并后的数组，并返回逆序对数

1. count ← 0
2. i ← l
3. j ← mid + 1
4. for k ← l to r do
5.     if (j > r) or (i ≤ mid and A[i] ≤ A[j]) then
6.         temp[k] ← A[i]
7.         i ← i + 1
8.     else
9.         temp[k] ← A[j]
10.        j ← j + 1
11.        count ← count + (mid - i + 1) // 计算逆序对数
12. for i ← l to r do
13.    A[i] ← temp[i]
14. return count

算法：MergeSort
输入：数组 A，临时数组 temp，区间起点 l，终点 r
输出：数组 A 在区间 [l..r] 内有序，并返回逆序对数

1. if l < r then
2.    mid ← l + (r - l) / 2
3.    leftCount ← MergeSort(A, temp, l, mid)
4.    rightCount ← MergeSort(A, temp, mid + 1, r)
5.    mergeCount ← Merge(A, temp, l, mid, r)
6.    return leftCount + rightCount + mergeCount
7. else
8.    return 0

```

### 快速排序——白盒划分典型问题

**处理思想：![image-20241209084930516](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209084930516.png)**



**处理流程：<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209085004356.png" alt="image-20241209085004356" style="zoom: 80%;" />**



**时间复杂度分析：**与划分是否对称有关

![image-20241209090403280](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209090403280.png)

**实现代码：**

时间复杂度：最佳/平均：$O(nlogn) = $  $logn$（递归深度）*$O(n)$（每层分割操作）

​			最坏： $O(n^2)$

```c++
算法：QuickSort
输入：数组 A，区间起点 l，终点 r
输出：数组 A 在区间 [l..r] 内有序

1. if l < r then
2.    i ← l
3.    j ← r
4.    x ← A[l] // 选取哨兵元素
5.    while i < j do
6.        // 从右向左搜索，找小于哨兵的元素
7.        while i < j and A[j] ≥ x do
8.            j ← j - 1
9.        if i < j then
10.           A[i] ← A[j]
11.           i ← i + 1
12.       // 从左向右搜索，找大于哨兵的元素
13.       while i < j and A[i] ≤ x do
14.           i ← i + 1
15.       if i < j then
16.           A[j] ← A[i]
17.           j ← j - 1
18.    A[i] ← x // 将哨兵放置在正确位置
19.    QuickSort(A, l, i - 1) // 递归处理左子数组
20.    QuickSort(A, i + 1, r) // 递归处理右子数组
```



### 最接近点对——白盒划分典型问题

**基本思想：**

1. **排序**： 将所有的点按照横坐标（x坐标）的值进行排序，更容易地将问题分解为子问题。
2. **分割**： 将排序后的点集分成两个子集，分别包含左半部分和右半部分的点。通常，分割可以通过垂直线将点集分为两半，每半包含相等数量的点。如果点的数量是奇数，则分割可以选择左侧多一些或右侧多一些。
3. **递归求解**： 对左侧和右侧的子集递归地求解最接近点对问题。这将产生左侧子集和右侧子集的最近点对以及它们的距离。
4. **合并结果**： 在递归的过程中，得到了左侧和右侧子集的最近点对和距离。现在，需要考虑在左侧和右侧子集之间的最接近点对。
5. **跨越线上的点对**： 在合并结果时，需要考虑跨越左右子集之间的点对，这些点对可能是最接近的。通常，这部分工作是在分治的同时完成的。
6. **返回最小距离**： 最终，通过比较左侧、右侧和跨越线上点对的距离，确定最接近点对的距离，并返回最小距离。

![image-20241209101936196](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209101936196.png)

**代码实现：**

时间复杂度：$O(nlogn) = $  $logn$（递归深度）*$O(n)$（每层处理操作）

在每次分解后，还需要处理跨越分割边界的点集。首先，选出可能与最小距离相关的点，时间复杂度是 $O(n)$（最坏情况下，所有点都可能与当前最小距离相关）。接着，检查这些点之间的距离，需要 $O(k)$次比较，其中 $k$是跨越分割边界的点数。为了优化，最多检查 $5$ 个点，因此这个部分的时间复杂度是 $O(k)$，并且 $k$最多是 $O(n)$，但是由于限制条件，实际上常数因子是很小的。

```c++
结构：Point
属性：x, y（双精度）

算法：Merge
输入：整型区间起点 l，中点 mid，终点 r
输出：点数组 point 在区间 [l..r] 按 y 坐标有序
1. n1 ← mid - l + 1 // 左侧点集大小
2. n2 ← r - mid     // 右侧点集大小
3. L ← 长度为 n1 的点数组
4. R ← 长度为 n2 的点数组
5. for i ← 0 to n1 - 1 do
6.     L[i] ← point[l + i]
7. for i ← 0 to n2 - 1 do
8.     R[i] ← point[mid + 1 + i]
9. i ← 0
10. j ← 0
11. for k ← l to r do
12.     if i < n1 and (j ≥ n2 or L[i].y < R[j].y) then
13.         point[k] ← L[i]
14.         i ← i + 1
15.     else
16.         point[k] ← R[j]
17.         j ← j + 1

算法：Divide
输入：整型区间起点 l，终点 r
输出：区间 [l..r] 中最近点对的最小距离
1. if l = r then
2.     return INF // 只有一个点，返回无穷大
3. if l + 1 = r then
4.     if point[l].y > point[r].y then
5.         交换 point[l] 和 point[r]
6.     return dis(point[l], point[r])
7. mid ← ⌊(r + l) / 2⌋ // 计算中点
8. mid_x ← point[mid].x
9. min_dist ← Min(Divide(l, mid), Divide(mid + 1, r))
10. Merge(l, mid, r)
11. temp ← 长度为 (r - l + 1) 的点数组
12. i_size ← 0
13. for i ← l to r do
14.     if Abs(point[i].x - mid_x) ≤ min_dist then
15.         temp[i_size] ← point[i]
16.         i_size ← i_size + 1
17. for i ← 0 to i_size - 1 do
18.     for j ← i + 1 to Min(i_size - 1, i + 5) do
19.         if temp[j].y - temp[i].y > min_dist then
20.             break
21.         if dis(temp[i], temp[j]) < min_dist then
22.             min_dist ← dis(temp[i], temp[j])
23. return min_dist
    
函数：Main
输入：点数组 p，大小为 length
输出：\
1. Sort(p, cmpx) // 按 x 坐标排序
2. Divide(0, length - 1)
```

### 乘方运算——减治策略

![image-20241209123417948](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209123417948.png)

### 二分查找——减治策略

![image-20241209123509779](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209123509779.png)

**代码实现：**

时间复杂度：$O(logn)$

```c++
算法：BinarySearch
输入：数组 A，整型区间起点 l，终点 r，目标值 q
输出：目标值 q 在数组中的索引；如果未找到，则返回 -1
1. while l ≤ r do
2.    mid ← l + (r - l) / 2 // 计算中点
3.    if A[mid] = q then
4.        return mid // 找到目标值，返回索引
5.    if A[mid] > q then
6.        r ← mid - 1 // 在左半部分查找
7.    else
8.        l ← l + 1 // 在右半部分查找
9. return -1 // 如果未找到目标值，返回 -1
```

### 幂乘算法

**问题描述**

输入：$a$为给定实数，$n$为自然数

输出：$a^n$

**分治算法** 

时间复杂度:$O(logn)$

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215202508518.png" alt="image-20241215202508518" style="zoom: 67%;" />

**应用：Fibonacci数列**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215202620683.png" alt="image-20241215202620683" style="zoom: 67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215202632845.png" alt="image-20241215202632845" style="zoom: 67%;" />

### 选最大最小

分组：元素两两一组

分治：数组分为两个子数组，递归求解

![image-20241215213152383](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215213152383.png)

### 选第二大

**锦标赛算法**

1. 两两分组比较，大者进入下一轮，直到剩下 1个元素 $max$ 为止
2. 在每次比较中淘汰较小元素，将被淘汰元素记录在淘汰它的元素的链表上
3. 检查$max$的链表，从中找到最大的元即为$second$

时间复杂度：$O(n+\lceil logn \rceil-2)$

```c++
算法 FindSecond
输入: n个数的数组 L, 输出: second
1．k<-n // 参与淘汰的元素数
2．将k个元素两两1组, 分成 ⌊k/2⌋ 组
3．每组的2个数比较，找到较大数
4．将被淘汰数记入较大数的链表
5．if k 为奇数 then k<-⌊k/2⌋+1
6．else k<-⌊k/2⌋
7．if k>1 then goto 2
8．max<-最大数
9．second <- max 的链表中的最大
```

### 一般性选择问题（选第$k$小）

**简单算法**

1. 调用$k$次选最小算法,$O(kn)$
2. 先排序，然后输出第$k$小的数,$O(nlogn)$

**分治算法**

1. 用某个元素$m^*$作为标准将$S$划分为$S_1$与$S_2$，其中$S_1$的元素小于$m^*$，$S_2$的元素大于等于$m^*$
2. 如果$k ≤|S1|$，则在$S_1$中找第$k$小，如果$k=|S_1|+1$，则$m^*$是第$k$小，如果$k>|S_1|+1$，则在$S_2$中找第$k-|S_1|-1$小

```
算法：Select(S,k)
输入：数组S，正整数k
输出：S中的第k小元素
1．将S分5个一组, 共 nM = ⌈n/5⌉组
2．每组排序,中位数放到集合 M
3．m*<-Select(M,⌈|M|/2⌉) //S分A,B,C,D
4．A,D元素小于m*放 S1,大于m*放S2
5．S1 <- S1 U C; S2 <- S2 U B
6．if k = |S1| + 1 then 输出 m* 
7．else if k <= |S1| 
8． then Select (S1, k)
9. else Select (S2, k－|S1|－1)
```

# 动态规划

- 基本原则：“**空间换时间**”
- 底层运算：“**表格操作**”
- 实现路线：“**子问题**划分、**自底向上**求解”

## 基本要素

### 最优子结构

- 最优子结构性质，通俗地讲就是**问题的最优解包含其子问题的最优解**。也就是说，如果把问题的最优解分解（比如划分为两个或者多个部分，或者删除第一个或者最后一个分量），得到一个子解，那么这个**子解**是其**相应子问题**的**最优解**。

- 最优子结构性质**隐含了问题最优解和子问题最优解之间的一种递推关系**。它是动态规划的基础，递推方程是最优子结构性质的体现。

- 在分析问题的最优子结构性质时，人们一般采用**<u>反证法</u>**：首先假设由问题最优解S导出的子问题的解不是最优的，然后再推导在这个假设下可构造出比S更好的解 S’，从而得到矛盾。

**注意：** **同一个问题可以有多种方式刻划它的最优子结构**

### 重叠子问题

- **子问题的重叠性质**：递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。

- 动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，

​	只是简单地用常数时间查看一下结果。

- 通常不同的子问题个数随问题的大小呈**多项式**增长。因此用动态规划算法只需要多项式时间，从而获

​	得较高的解题效率。

## 动态规划算法设计步骤

1. 分析最优解的性质，并刻划其**最优子结构**特征；
2. 确定**状态表示**$S(x_1,x_2,…)$和**状态递推方程**，递归地定义最优值；
3. 确定**状态转移顺序**，以自底向上的方式计算出最优值；
4. 根据计算最优值时得到的信息，**构造最优解**。

## 矩阵连乘问题 *

### 完全加括号

 **矩阵连乘计算次序**用**加括号的方式**来确定。特别的，**完全加括号**的矩阵连乘积可**递归地定义**为：

- 单个矩阵是完全加括号的
- 矩阵连乘积 A 是完全加括号的，则 A 可示为2个完全加括号的矩阵连乘积 B 和 C 的乘积并加括号，即 A=（BC）

### 问题分析

给定n个矩阵$A_1$, ⋯ , $A_n$，其中第i个矩阵的维度为$p_{i-1}*p_i$ ，以及它们的一个完全加括号方案：

$((A_1(A_2...A_k))((A_{k+1}A_{k+2})...A_n)$，记为$a$，该完全加括号方案所需数乘次数包括三部分：

1. $((A_1(A_2...A_k))$，记为$b$
2. $((A_{k+1}A_{k+2})...A_n)$，记为$c$
3. 上述两个结果矩阵相乘所需要的数乘次数，记为$p_0p_kp_n$

$$
a = b + c + p_0p_kp_n
$$

### 最优子结构性质

假设 𝑛 个矩阵连乘的**最优加括号方案**为 $((A_1(A_2...A_k))((A_{k+1}A_{k+2})...A_n)$（省略了 $A_1 ⋯ 𝐴_𝑘$和$𝐴_{𝑘+1} ⋯ 𝐴_𝑛$ 内部的括号），则加括号方案 $(𝐴_1 ⋯ 𝐴_𝑘)$ 是子矩阵链$𝐴_1 ⋯ 𝐴_𝑘$的**最优方案**，$(𝑨_{𝒌+𝟏} ⋯ 𝑨_𝒏)$ 是子矩阵链$𝑨_{𝒌+𝟏} ⋯ 𝑨_𝒏$的**最优方案**。

**反证法：**原问题的原问题的最优加括号方案假设为$((A_1(A_2...A_k))((A_{k+1}A_{k+2})...A_n)$，如果$(A_1(A_2...A_k))$ 不是$A_1...A_k$的最优方案，则$A_1...A_k$至少存在一个加括号方案，其数乘次数𝑏 ′少于𝑏，该方案记为$((A_1A_2)...A_k)$

可以构造原问题的另外一个加括号方案：$((A_1A_2)...A_k))((A_{k+1}A_{k+2})...A_n)$

得到 $𝑎 = 𝑏 + 𝑐 + 𝑝_0𝑝_𝑘𝑝_𝑛$ 且 $𝑎 ′ = 𝑏 ′ + 𝑐 + 𝑝_0𝑝_𝑘𝑝_𝑛$

因为 $𝑏 ′ < 𝑏$ ，所以 $𝒂 ′ < a$，与原假设$a$为最优加括号方案矛盾

### 状态表示和递推方程

- 状态表示本质上是**子问题的表征**：每一个**子矩阵链**𝐴𝑖 ⋯ 𝐴𝑗 对应一个**子问题**，它由开始矩阵和结束矩阵的**下标**决定，记为𝐴[𝑖:𝑗]。

- 𝐴[𝑖:𝑗]的最优计算次序对应的乘法次数表示为𝒎 (𝒊,𝒋) , 1 ≤ 𝑖,𝑗 ≤n，

- **原问题**的最优值为𝐦 (𝟏,𝐧) 。

![image-20241209131702689](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209131702689.png)

### 子问题个数和求解顺序

- 一个**有序对** 𝑖,𝑗 对应于一个**子问题**𝑚(𝑖,𝑗)，则子问题的个数最多有：$C^2_n+n = O(n^2)$个

- **自底向上**的顺序进行求解，或者说**从易至难**的顺序：先计算规模比较小或者说比较容

  易求解的子问题，并且**把子问题的答案**保存**在状态数组中，规模比较大的或者说**比较

  **困难的子问题**的答案则由**已求解子问题的答案**构造得到。

### 构造最优解

![image-20241209134315835](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209134315835.png)

### 代码实现

时间复杂度：$O(n^3)$

```c++
算法：MatrixChain
输入：矩阵链长度 n，数组 A 记录矩阵维度（A[0..n]）
输出：矩阵链最小乘法次数 m[i][j] 和分割点 s[i][j]
1. for i ← 1 to n do
2.    m[i][i] ← 0 // 初始化对角线为 0
3. for r ← 2 to n do // r 表示矩阵链的长度
4.    for i ← 1 to n - r + 1 do // 逐个矩阵链段进行计算
5.        j ← i + r - 1 // 计算矩阵链的结束位置
6.        m[i][j] ← m[i][i] + m[i + 1][j] + A[i - 1] * A[i] * A[j] // 初始化最优值
7.        s[i][j] ← i // 记录分割点
8.        for k ← i + 1 to j - 1 do // 测试不同的分割位置
9.            t ← m[i][k] + m[k + 1][j] + A[i - 1] * A[k] * A[j] // 当前分割的代价
10.           if t < m[i][j] then
11.               m[i][j] ← t // 更新最优代价
12.               s[i][j] ← k // 更新分割点
```

### 递归方法：

**指数级别时间复杂度！**$O(2^n)$

```c++
算法：MatrixChain
输入：整型起点 i，终点 j，数组 a 表示矩阵维度（a[0..n]）
输出：从矩阵 i 到矩阵 j 的最小计算代价
1. if i = j then
2.    return 0
3. min ← 10000000 // 初始化为一个足够大的数字
4. for k ← i to j - 1 do
5.    ans ← MatrixChain(i, k) + MatrixChain(k + 1, j) + a[i - 1] * a[k] * a[j] // 计算分割代价
6.    if ans < min then
7.        min ← ans // 更新最小代价
8. return min // 返回从 i 到 j 的最小计算代价\
```

### 备忘录方法：（记忆化搜索）*

备忘录方法用表格保存已解决的子问题的答案，在下次需要解决此问题时，只要从表格中提取答案即可；如果没有求解，则递归调用求解过程进行计算。
时间复杂度：$O(n^3)$

```c++
算法：MatrixChain
输入：整型起点 i，终点 j，数组 a 表示矩阵维度（a[0..n]），memoTable 用于备忘录记录
输出：从矩阵 i 到矩阵 j 的最小计算代价

1. if memoTable[i][j] ≠ -1 then
2.    return memoTable[i][j] // 如果备忘录中已经有答案，直接返回
3. if i = j then
4.    memoTable[i][j] ← 0 // 单个矩阵的乘法代价为 0
5.    return 0
6. min ← 10000000 // 初始化为一个足够大的数字
7. for k ← i to j - 1 do
8.    ans ← MatrixChain(i, k) + MatrixChain(k + 1, j) + a[i - 1] * a[k] * a[j] // 计算分割代价
9.    if ans < min then
10.       min ← ans // 更新最小代价
11. memoTable[i][j] ← min // 存储当前计算的最小代价到备忘录
12. return min // 返回从 i 到 j 的最小计算代价
```

## 投资问题

**问题描述**m元钱，n项投资，$f_i(x)：$将x投入第i个项目的效益，使得总效益最大的投资方案

**建模** 问题的解是向量$<x_1,x_2,...,x_n>$，$x_i$是投给项目$i$的钱数，目标函数$max\{f_1(x)+f_2(x)+...+f_n(x)\}$，约束条件$x_1+x_2+...+x_n=m$

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241215232332438.png" alt="image-20241215232332438" style="zoom:80%;" />

------

**伪代码**

```
算法：投资问题
输入：二维数组 f，整数 n 和 m
输出：dp[n][m] 的最大值
1. for i ← 1 to n do
2.     for j ← 0 to m do
3.         dp[i][j] ← 0
4.         for k ← 0 to j do
5.             if dp[i][j] < f[i][k] + dp[i-1][j-k] then
6.                 dp[i][j] ← f[i][k] + dp[i-1][j-k]
7. return dp[n][m]
```



## 多段图最短路径

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209144807893.png" alt="image-20241209144807893" style="zoom:150%;" />

------

### 最优子结构性质

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209144828427.png" alt="image-20241209144828427" style="zoom:150%;" />

------

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209144849097.png" alt="image-20241209144849097" style="zoom:150%;" />

### 状态表示

**包含源s的子图**都可以认为是一个子问题，子图的**源是固定的，汇是变化**的。因此，确定了汇的位置，则能确定一个子图。汇的位置包括**两个参数**：**段的序号**和该段顶点集合中**汇顶点的序号**。

$W(i,p)$表示从源$s$到$v(i,p)$的最短路径长度:

### 状态递推方程

- $i(1 ≤ 𝑖 ≤ 𝑘)$表示段的序号（**<u>解释：$V_i$包含的所有点为一个段</u>**）
- $𝑝(1 ≤ 𝑝 ≤ 𝑛_𝑖 )$表示第 i 段顶点集中的顶点序号

![image-20241209152255253](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209152255253.png)

### 最优值求解

- 子问题的数目等于图G中**顶点的个数**。

- 采用**自底向上**的方法求最优值，最开始求解源s到第2段顶点集中每一个顶点的最短路径。这是最简单的子问题，最优值就等于边长。

- 然后求解s到第3段顶点集中的每一个顶点的最优值，依此循环，直至求解s到t的最短路径值。

### 算法实现

时间复杂度：$O(n^2*m)$

```c++
算法：Mult_iStageGraph
输入：整型 stageNum 表示阶段数，数组 V 表示每个阶段的顶点数，minRoad 为存储最短路径的数组
输出：从最后一段的汇点到源顶点的最短路径

1. for i ← 0 to stageNum - 1 do
2.    for j ← 0 to V[i] - 1 do
3.        minRoad[i][j] ← INF // 初始化最短路径为足够大的数字
4. for p ← 0 to V[0] - 1 do
5.    minRoad[0][p] ← 0 // 初始化源顶点层的最短路径为 0
6. for i ← 0 to stageNum - 2 do // 直到倒数第二段
7.    for q ← 0 to V[i] - 1 do // 遍历第 i 段的每个顶点
8.        input weight
9.        if weight ≠ -1 then // 如果边存在（权重不是 -1）
10.            temp ← minRoad[i][q] + weight // 计算到 p 的路径长度
11.            for p ← 0 to V[i + 1] - 1 do // 遍历下一段的每个顶点
12.                if temp < minRoad[i + 1][p] then
13.                    minRoad[i + 1][p] ← temp // 更新最短路径
14. return minRoad[stageNum - 1][0] // 返回从最后一段的汇点到源顶点的最短路径
```

## 最长公共子序列

![image-20241209155003254](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209155003254.png)

### 最优子结构性质

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209155252200.png" alt="image-20241209155252200"  />

### 状态表示

- 输入序列对 $𝑋_{𝑚−1}, 𝑌_{𝑛−1} ， 𝑋_{𝑚−1}, 𝑌_{𝑛} 和 𝑋_{𝑚}, 𝑌_{𝑛−1}$ 都分别表示一个**子问题**

- 子问题可以通过**两个参数**确定，即**序列 X 的长度**和**序列 Y 的长度**
- 𝐂(𝐢, 𝐣)表示序列$𝑋_𝑖 = 𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑖$ 和$𝑌_𝑗 = 𝑦_1, 𝑦_2, ⋯ , 𝑦_𝑗$ 的最长公共子序列长度
- C(m, n)则表示**原问题**的最长公共子序列长度

### 状态递推方程

- 当i = 0或𝑗 = 0时，𝐶(i,𝑗) = 0；

- 当i, j > 0时，𝐶(i,𝑗)的求解包括**两种情况**：
  1. $𝑥_𝑖=𝑦_𝑗$：$𝑋_{𝑖−1}$,$𝑌_{𝑗−1}$的最长公共子序列末尾**添加**元素$𝑥_𝑖(= 𝑦_𝑗)$，即可得到 $𝑋_𝑖 , 𝑌_𝑗$ 的最长公共子序列
  2. $𝑥_𝑖≠𝑦_𝑗$：$𝑋_𝑖 , 𝑌_𝑗$ 的最长公共子序列等于 $𝑋_𝑖,𝑌_{𝑗−1}和𝑋_{𝑖−1},𝑌_{𝑗}$ 的最长公共子序列的**较大者**

### 计算最优值

- 总共有Θ(𝑛𝑚)个子问题，**自底向上地**求解每一个子问题𝐶(𝑖,𝑗)，并且保存在数组$C[i][j]$中

  - $C[0][j]$和$C[i][0]$的值初始化为0，此时表示有一个输入串为空；

  - 求解$𝑋_1 = 𝑥_1$ 与所有$𝑌_𝑗 , 0 ≤ 𝑗 ≤ 𝑛$的最长公共子序列长度，即$C[1][j]$

  - 求解$𝑋_2 = 𝑥_1, 𝑥_2$ 与所有$𝑌_𝑗 , 0 ≤ 𝑗 ≤ 𝑛$的最长公共子序列长度，即$C[2][j]$

  - 求解$𝑋_𝑚 = 𝑥_1, ⋯ , 𝑥_𝑚$与所有$𝑌_𝑗 , 0 ≤ 𝑗 ≤ 𝑛$的最长公共子序列长度，即$C[m][j]$

- 怎么获取最长公共子序列？

  - 关键是子问题之间的关系，用一个二维数组B记录： 

  - $B[i][j]$ = 1，表示$C[i][j]$的值从$C[i-1][j-1]$得到，$X[i]$是公共字符

  - $B[i][j]$= 2，表示$C[i][j]$的值从$C[i-1][j]$得到

  - $B[i][j]$= 3，表示$C[i][j]$的值从$C[i][j-1]$得到

### 算法实现

时间复杂度：$O(n*m) = LcsLength：O(n*m)+LCS：O(n+m)$

```c++
算法：LcsLength
输入：字符串 strX 和 strY
输出：字符串 strX 和 strY 的最长公共子序列（LCS）的长度

1. m ← Length(strX) + 1
2. n ← Length(strY) + 1
3. Initialize C as a 2D Array of size [m][n] with all values set to 0
4. Initialize B as a 2D Array of size [m][n]
5. for i ← 1 to m - 1 do
6.    for j ← 1 to n - 1 do
7.        if strX[i - 1] == strY[j - 1] then
8.            C[i][j] ← C[i - 1][j - 1] + 1
9.            B[i][j] ← 1 // Diagonal move
10.       else if C[i - 1][j] ≥ C[i][j - 1] then
11.           C[i][j] ← C[i - 1][j]
12.           B[i][j] ← 2 // Move up
13.       else
14.           C[i][j] ← C[i][j - 1]
15.           B[i][j] ← 3 // Move left
16. return C[m - 1][n - 1] // Return the length of LCS


算法：LCS
输入：整型 i 和 j，字符串 strX 和 2D 数组 B
输出：字符串 strX 和 strY 的最长公共子序列（LCS）

1. if i == 0 or j == 0 then
2.     return
3. if B[i][j] == 1 then
4.     LCS(i - 1, j - 1, strX, B)
5.     output strX[i] // Output the current LCS character
6. else if B[i][j] == 2 then
7.     LCS(i - 1, j, strX, B) // Move up
8. else
9.     LCS(i, j - 1, strX, B) // Move left
```

- **IcsLength的时间复杂度为O(nm)，空间复杂度也为O(nm)**，需要两个二维数组来存储最优值和最优方案
- **改进方案1**：在$C[i-1][j-1]$中存储B[i][j]的值，省略B的存储空间
- **改进方案2**：如果只需要求最长公共子序列的长度，则存储空间可以缩小到2n

##  0-1背包问题 *

### 最优子结构性质

![image-20241209170711204](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209170711204.png)

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209171058938.png" alt="image-20241209171058938" style="zoom:80%;" />

### 状态表示

- 子问题可由两个参数确定：待考虑装包的物品集和背包的剩余容量

- 将所有物品按照1至n 标号，待考虑装包的物品集可以用物品集中末尾物品的标号来描述，则得状态表示𝑽𝒂𝒍(𝒊, 𝒑), 1 ≤ 𝑖 ≤ 𝑛, 0 ≤ 𝑝 ≤ 𝐶 表示在**背包剩余容量**为𝑝，**待考虑装包的物品集为{1, 2, …, i}**时的最大装入物品价值。

- $𝑽𝒂𝒍(n, C)$则表示**原问题**的最优解。

### 递推方程



![image-20241209185126988](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209185126988.png)

### 计算最优值

- 0-1背包问题包含𝜽(𝒏𝑪)**个子问题**，采用自底向上的方法求最优值，最优值保存在二维数组Val中。

- 最开始的时候根据边界条件计算Val中第一行的值，它是最简单的子问题。然后,根据递推公式计算Val的第二行，第三行，一直到第n 行。

### 算法实现

时间复杂度：$O(n*m)$

```c++
算法：fun1
输入：整数 n, m；数组 f 表示当前状态值，w 表示重量，v 表示价值
输出：背包问题的最大价值
1. for i ← 1 to n do
2.     for j ← 1 to m do
3.         if j < w[i] then
4.             f[i][j] ← f[i - 1][j] // 不选当前物品
5.         else
6.             f[i][j] ← Max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]) // 选当前物品
7. return f[n][m] // 返回最大价值

```

```c++
算法：fun2
输入：整数 n 和 m；数组f 表示当前状态值，数组 w 表示物品重量，v 表示物品价值
输出：背包问题的最大价值
1. for i ← 1 to n do
2.     for j ← m down to w[i] do
3.         f[j] ← Max(f[j], f[j - w[i]] + v[i]) // 更新背包容量为 j 时的最大价值
4. return f[m] // 返回背包容量为 m 时的最大价值
```

# 贪心算法

## 贪心算法设计要素

1. 贪心算法适用于组合优化问题
2. 求解过程是多步判断过程，最终的判断序列对应于问题的最优解(**最优子结构**)
3. 依据某种“短视的”**贪心选择性质**判断，性质好坏决定算法成败
4. 贪心法必须进行正确性证明
5. 证明贪心法不正确的技巧：举反例

 贪心法的优势：算法简单，时间和空间复杂性低

## 贪心算法正确性证明 **

### 第一数学归纳法

- **归纳基础：**证明$P(1)/P(0)$为真
- **归纳步骤：**若对所有n有$P(n)$为真，证明$P(n+1)$为真

$P(1)=>P(2)=>P(3)...$

### 第二数学归纳法

- **归纳基础：**证明$P(1)/P(0)$为真
- **归纳步骤：**若对所有小于n的k有$P(k)$为真，证明$P(n)$为真

$P(1)=>P(2)、P(1)P(2)=>P(3)、P(1)P(2)P(3)=>P(4)$

### 算法正确性归纳证明

1. 叙述一个有关自然数的命题，该命题断定该贪心策略的执行最终将导致最优解、其中自然数n可以代表算法步数或者问题规模
2. 证明命题对所有的自然数为真，归纳基础（从最小实例规模开始）归纳步骤（第一或第二数学归纳法）

## 活动选择问题 *

### 活动选择策略

**结束早的优先**，排序使$f_1≤f_2≤...≤f_n$，从前向后挑选

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209192628945.png" alt="image-20241209192628945" style="zoom:80%;" />

### 活动选择策略证明 **

**命题：**算法执行到第$k$步，选择$k$项活动$i_1 = 1,i_2,...,i_k$则存在最优解$A$包含活动$i_1 = 1,i_2,...i_k$。根据上述命题：对于任何$k$，算法前$k$步的选择都将导致最优解，至多到n步将得到问题实例的最优解。

​	令$S = {1,2,....,n}$是活动集，且$f_1≤...≤f_n$

**归纳基础：$k = 1$，证明存在最优解包含活动1（结束时间最早的活动）**

*证明：*任取最优解$A$，$A$中活动按截止时间递增排列，这里记$A$的第一个活动为 k 

1. 若k = 1，即$A$的第一个活动就是最早结束的，故$A$是以贪心选择开始的最优解

2. 若k ≠ 1，设集合$B = (A-\{k\})U\{1\}$，即用活动1替换掉活动k。

   因为1的结束时间小于k，故1比k提前结束。且由于$A$中的活动是相容的，故$B$中的活动也相容。又因为$A$中的活动个数和B中的活动个数相同，故B也是最优解，所以$B$是以贪心选择活动1为开始后的最优活动。

**归纳步骤：假设命题对k为真，证明对k+1也为真**

*证明*：

1. 算法执行到第k步，选择了活动$i_1=1,i_2,...,i_k$，根据归纳假设存在最优解$A^*$包含$i_1=1,i_2,...,i_k$，$A^*$中剩下活动选自集合$B$（因为$S2$的活动与$A^*$冲突，$B$一定来自$S1$），且**B为S1的最优解**（假设$B$不是$S1$的最优解，即$S1$存在最优解C的活动数多于$B$，即$|AUC|>|A^*| = |AUB|$，与$A^*$为最优解的假设矛盾，因此假设不成立）。

2. 将$S1$看作子问题，则在$S1$中，根据**归纳基础**，必定存在一个结束时间最早的活动，即$i_{k+1}$。

   因此，$S1$存在最优解$B^*$包含活动$i_{k+1}$。而$B$和$B^*$都是$S1$的最优解，因此二者包含的活动个数相同。用$B^*$代替$B$最优解的性质不变（$AUB$的活动和$AUB^*$的活动个数相同）。而$B*$包含了$i_{k+1}$，故证明了第$k+1$项也是最优解。

![image-20241209205007029](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209205007029.png)

## 最优装载问题 *

### 问题描述

有一批集装箱要装上一艘载重量为$c$的轮船。其中集装箱i的重量为$w_i$ 。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。

### 算法设计

利用 **重量最轻的先装载** 进行贪心选择。

1.  对所有物品排序，同时记录物品序号
2.  每次选择重量最轻的物品放入，然后判断是否超重
3.  重复2步骤直到超重停止
4.  处理并输出答案

### 正确性证明 **

**命题：**对装载问题任何规模为n的输入实例，算法得到最优解

​	设集装箱从轻到重记为1,2,...,n

**归纳基础**：证明对任何只含1个箱子的输入实例，贪心法得到最优解，显然正确

**归纳步骤**:假设对于任何n个箱子的输入实例，贪心法都能够得到最优解，那么对于任何n+1箱子的输入实例贪心法也得到最优解

*证明*：*（$N_i$表示规模为 $i$ 的输入实例，$I_i$表示 $i$ 个集装箱对应的最优解）*

1. 假设对于n个集装箱的输入$N_{n}$，贪心法都能够得到最优解$I_n$。考虑n+1个集装箱的输入$N_{n+1}= \{1,2,...,n+1\},$，其中$w_1 ≤ w_2 ≤ ... ≤ w_{n+1}$
2. 由归纳假设，对于$N_{n}=\{2,3,...,n,n+1\},c_{n} = c_{n+1} - w_1$，贪心法得到最优解$I_{n}$。令$I_{n+1} = \{1\}UI_{n}$，则$I_{n+1}$**是关于$N_{n+1}$的最优解**
3. 假设$I_{n+1}$不是关于$N_{n+1}$的最优解，那么存在包含1的关于$N_{n+1}$的最优解$I_{n+1}^*$（如果$I_{n+1}^*$中没有1，用1替换$I_{n+1}^*$的第一个元素得到的解也是最优解），且$|I_{n+1}^*|>|I_{n+1}|$，那么$I_{n+1}^*-\{1\}$也是$N_{n+1}$的最优解，且$|I_{n+1}^*-\{1\}| > |I_{n+1} - \{1\}| = |I_{n}|$，与$I_n$的最优性矛盾，所以$I_{n+1}$**是关于$N_{n+1}$的最优解**

![image-20241209225127298](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209225127298.png)

## 最小延迟调度问题

### 问题描述

给定等待服务的客户集合A，预计对客户i的服务时长为$t_i$>0，客户i希望的服务完成时刻为$d_i$>0。一个调度f:A→N，f(i)为客户i的开始时刻。如果对客户i的服务在$d_i$之前结束，那么对客户i的服务没有延迟，即如果在$d_i$之后结束，那么这个服务就被延迟了，延迟的时间等于该服务的实际完成时刻f(i)+$t_i$减去预期结束时刻$d_i$。一个调度f的最大延迟是所有客户延迟时长的最大值max{f(i)+t-$d_i$}。使用贪心策略找出一个调度使得最大延迟最小。

### 三种贪心策略

1. 按照$t_i$从小到大安排（举反例：**得不到最优解**）
2. 按照$d_i-t_i$从小到大安排（举反例：**得不到最优解**）
3. 按照$d_i$从小到大安排

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209232049257.png" alt="image-20241209232049257" style="zoom: 67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209232108369.png" alt="image-20241209232108369" style="zoom: 67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209231949847.png" alt="image-20241209231949847" style="zoom:67%;" />

### 贪心策略伪代码实现

**设计思想**：按完成时间从早到晚安排任务，没有空闲

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209232827544.png" alt="image-20241209232827544" style="zoom:80%;" />

### ~~交换论证——正确性证明~~

**证明思路：**

1. 分析**一般最优解与算法解**的区别（成分，排列顺序不同）
2. 设计一种**转换操作**（替换成分或交换次序），可以在有限步内将任意一个普通最优解逐步转化为算法的解
3. 上述每步转换都**不降低解的最优性质**（*没有空闲时间，没有逆序*）

**引理1：**所有没有逆序、没有空闲时间调度具有相同的最大延迟

*证明：*设$f$没有逆序，在$f$中具有相同完成时间$d$的客户$i_1,i_2,...,i_k$连续安排，其开始时刻为$t_0$，完成这些任务的时刻是$t$，最大延迟为最后任务延迟$t-d$，与$i_1,i_2,...,i_k$的排列次序无关，
$$
t = t_0 + (t_{i_1} + t_{i_2} + ... + t_{i_k})
$$
**证明要点：**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209234919917.png" alt="image-20241209234919917" style="zoom: 67%;" />

**交换相邻逆序仍旧最优：**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209234909293.png" alt="image-20241209234909293" style="zoom:67%;" />

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209234932539.png" alt="image-20241209234932539" style="zoom:67%;" />

**总结：**

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241209234959292.png" alt="image-20241209234959292" style="zoom: 50%;" />

# 搜索算法

## 基本思想

- 不需要进行**子问题划分**，也没有直接的递推公式的求解，搜索算法是一种通用的问题求解方法：首先把问题转为一个状态空间图，然后设定特定的图遍历方法在状态空间中搜索问题的解
- 同时，为了提高搜索的效率，遍历状态空间时需要添加**优化技术**，比如剪枝策略用于避免不必要的无效搜索，启发式信息用来加速朝目标状态逼近的速度。

## 状态空间图

可以形式化地定义为一个四元组$(S,A,G,F)$

- $S$表示问题的初始状态，是搜索的起点
- $A$是采取的操作符集合，初始状态和操作符隐含地定义了问题的状态图
- $G$表示目标测试，它判断给定的状态是否为目标状态，他可以是表示目标状态的一个状态集合，也可以是一个判定函数
- $F$代表路径耗散函数，它的定义需要具体问题具体分析

**搜索**就是在状态空间图中从初始状态出发，执行特定的操作，试探地寻找目标状态的过程。当然，也可以从目标结点到初始结点反向进行。状态空间图中从初始状态到目标状态的路径则代表**问题的解**。解的优劣由路径耗散函数量度，最优解就是路径耗散函数值最小的路径。

## 搜索算法类型

###  深度优先搜索(DFS)

**基本思想**

![image-20241210130859228](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210130859228.png)

**算法框架**

```c++
算法：DFS（基于递归的框架）
输入：问题 problem, 当前节点 node
输出：目标解
1. if State[node] == Goal then
2.     return Solution(node) // 递归出口，找到目标状态，返回解
3. visit(node) // 访问当前节点
4. // 扩展 node 的所有未访问子节点
5. for Each sonNode in Init(node) to Last(node) do
6.     if notVisited(sonNode) then
7.         DFS(problem, sonNode) // 递归遍历其子树

算法：DFS（基于栈的框架）
输入：问题 problem, 栈 stack
输出：目标解或失败
1. node ← Make-Node(Initial-State[problem]) // 生成初始节点
2. stack ← Insert(node, stack) // 初始节点入栈
3. repeat
4.     if stack == Empty then
5.         return failure // 没有搜索到目标状态，返回失败
6.     node ← Remove-First(stack) // 取出栈顶元素
7.     visit(node) // 访问当前节点
8.     if State[node] == Goal then
9.         return Solution(node) // 搜索到目标状态，返回解
10.     sonNodes ← Expand(node, problem) // 扩展 node
11.     stack ← Insert-All(sonNodes, stack) // 全部未访问子节点入栈
12. until false
```

### 广度优先搜索(BFS)

**基本思想**

![image-20241210130921544](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210130921544.png)

**算法框架**

```c++
算法：BFS（基于队列的框架）
输入：问题 problem, 队列 queue
输出：目标解或失败
1. node ← Make-Node(Initial-State[problem]) // 生成初始节点
2. queue ← Insert(node, queue) // 初始节点入队
3. repeat
4.     if queue == Empty then
5.         return failure // 队列为空，未找到目标状态，返回失败
6.     node ← Remove-First(queue) // 取出队列的头部节点
7.     visit(node) // 访问当前节点
8.     if State[node] == Goal then
9.         return Solution(node) // 找到目标状态，返回解
10.     sonNodes ← Expand(node, problem) // 扩展 node，生成未访问子节点
11.     queue ← Insert-All(sonNodes, queue) // 将所有子节点依次入队
12. until false
```

### 回溯算法：

***本质**为深度优先搜索+剪枝策略*

**算法设计：**

- 针对所给问题，**定义问题的状态空间图**。
- 以**深度优先方式**搜索状态图，并用**剪枝策略**避免无效搜索。

**定义问题的状态空间图**：

![image-20241210132311520](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210132311520.png)

**剪枝策略的设计**：

1. **约束函数剪枝**：根据约束条件，状态空间图中的部分状态可能是**不合法**的，其子空间不需要搜索，即**约束函数剪枝可以剪除状态空间图中的不可行解**。
2. **限界函数剪枝**：这种策略一般应用于最优化问题。假设搜索算法当前访问的状态为𝑆，且存在一个判定函数，它能判定以𝑺为根的子图/子树**不包含最优解**，因此该子图/子树可以剪除而无需搜索。**限界函数剪枝用于剪除状态空间图中的可行但是非最优的解。**

```c++
算法：backtrack
输入：整数 t，当前层号
输出：当前解 x
1. if t > n then
2.     output(x) // 输出当前解 x
3. else
4.     for i ← Init(n, t) to Last(n, t) do
5.         x[t] ← Node(i) // 记录当前子节点的信息
6.         if constraint(x) and bound(x) then // 判断是否满足约束和限界条件
7.             backtrack(t + 1) // 递归调用，继续深度优先搜索
```



### 分支界限法 ***

***本质**为广度优先搜索+剪枝策略*

**算法设计**

1. 针对所给问题，定义问题的状态空间图
2. 以**广度优先方式搜索**状态空间图，并在搜索过程中用**剪枝策略**避免无效搜索

**实现步骤**

1. 将根结点加入队列中
2. 从队列中取出首结点，使其成为当前扩展结点，一次性生成它的所有孩子结点，**判断孩子结点是舍弃还是保存**。**舍弃那些不可能导致可行解或最优解的孩子结点**，其余结点保存。
3. 重复上述扩展过程，直到找到问题的解或队列为空时为止。

```c++
算法：BranchBound
输入：问题 problem，队列 queue（初始为空）
输出：目标解或失败
1. node ← Make-Node(Initial-State[problem]) // 生成初始状态结点
2. queue ← Insert(node, queue) // 初始结点加入队列
3. repeat// 无限循环，直到找到解或队列为空
4.     if queue == Empty then
5.         return failure // 队列为空，说明搜索没有找到目标，返回失败
6.     node ← Remove-First(queue) // 从队列中取出队头结点
7.     visit(node) // 访问当前结点
8.     if State[node] == Goal then
9.         return Solution(node) // 找到目标状态，返回解
10.    while (sonNode ← Next(problem, node)) ≠ NULL do
11.        if constraint(sonNode) and bound(sonNode) then
12.            queue ← Insert(sonNode, queue) // 满足约束和限界条件，插入子结点到队列
13. until false
```

### ~~启发式搜索~~

**基本思想**

1. 假设有一个**启发式（评估）函数**𝑓，可以帮助**选择**下一个要扩展的**最佳结点**。
2. 从活结点表中选择估值𝑓(𝑛)（n表示结点）**最佳**的结点作为扩展结点，并一次生成它的所有子结点，计算评估函数值，并放入活结点表中。
3. 当找到目标结点，或者活结点表为空时，算法结束。

**评估函数**
$$
f(n) = g(n) + h(n)
$$

- 𝑓(𝑛)为**经过当前结点**𝒏的从开始结点到目标结点的最佳路径成本的**估计**；

- g(𝑛)是在状态空间中从初始结点到当前结点𝑛的路径成本，它一般能根据当前状

态和路径计算得到，可以认为是**已知的**；

- h(n)是从当前结点𝑛到目标结点最佳路径成本的**估计**，它是**未知**的，体现了搜索

的启发信息。

**最小成本检索：**选择下一个扩展结点的策略总是选取𝑓(∙)值最小的活结点作为下一个扩展结点。

- **广度优先搜索和分支限界法**

  如果𝑔(𝑛)表示结点𝑛在解空间树中的深度, ℎ(𝑛) = 0

- **深度优先搜索和回溯法**

​	如果𝑔(𝑛) = 0，ℎ(𝑛)的定义满足：m是n的儿子结点，则ℎ(𝑚) < ℎ(𝑛)

- **A\***算法

​	满足ℎ(𝑛) ≤ ℎ ∗ (𝑛) ，其中ℎ ∗ (𝑛)表示结点𝑛到目标结点的**最佳路径成本**

## 传教士渡河问题——状态空间图 *

### 问题描述

在河的左岸有三个传教士、一条船和三个野人，传教士们想用这条船将所

有的成员都运过河去，但是受到以下条件的限制：

1.  教士和野人都会划船，但船**一次最多只能装运两个**；
2. 在任何岸边**野人数目都不得超过传教士**，否则传教士就会遭遇危险：被野人攻击甚至被吃掉。

此外，假定野人会服从任何一种过河安排，试设计出一个确保全部成员安全过河的计划。

### 解题思路

**1）状态表示**

确定问题的状态表示，以及每一个状态变量的值域。

渡河问题包括三类对象：传教士，野人和渡船，得**三元组**𝑺 = (𝒎, 𝒄, 𝒃)，其中：

- m为左岸传教士数，有𝑚 = {0, 1, 2, 3}；对应右岸的传教士数为3－𝑚。

- c为左岸的野人数，有𝑐 = {0, 1, 2, 3}；对应右岸野人数为3－𝑐。

- b为左岸渡船数，有𝑏 = {0, 1}，右岸的船数为1 − 𝑏。

**初始状态**只有一个，即$𝑆_0$ = (3, 3, 1)，表示全部成员在河的左岸；**目标状态**也只一个，即 $𝑆_𝑔$ = (0, 0, 0) ，表示全部成员从河左岸渡河完毕。

**2）操作符集合**

- 把船从左岸划向右岸定义为$L_{ij}$操作，$i$表示船载的传教士数，$j$表示船载的野人数
- 从右岸划回左岸称之为$K_{ij}$操作
- 共有十种操作，操作集为$F = \{L_{01},L_{10},L_{11},L_{02},L_{20},R_{01},R_{10},R_{11},R_{02},R_{20}\}$

**3）状态表**

表中的状态并不全都是合法的状态，可以删除非法的状态，加速搜索过程。

<img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210125344081.png" alt="image-20241210125344081" style="zoom:150%;" />

## 背包问题

### 问题描述

对于𝑛=3的0-1背包问题，其中背包容量𝑐 = 30，每个物品的重量和价值分别为：$𝑤=<16,15,15 >, 𝑝 =< 45,25,25 >$。

### 回溯算法

**1）问题状态的表示**

$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$ 其中k表示已经处理过的物品数目，$𝑥_𝑖 = \{0, 1\}$，如果$𝑥_𝑖 = 0$，则表示第$𝑖$个物品装入背包，否则物品未装入。$𝑋 =$[   ]是初始状态，表示所有物品都没有处理。

**2）约束条件**

- $x_i = \{0, 1\}$
- $\sum_{i=1}^k{x_iw_i}≤C$

**3）操作符**

给定状态$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$，可能的操作有两种：

- 把第k+1个物品**装入**背包，有$𝑥_{𝑘+1}=1$；

- 把第k+1个物品**不装入**背包，有$𝑥_{𝑘+1} = 0$；

得到一个新的状态$𝑋^` = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘,x_{k+1}]$

**4）问题解和解空间**

- 满足约束条件的任何**3维0-1向量**$[𝑥1, 𝑥2, 𝑥3]$都是0-1背包问题的一个解

- 解空间可以用一棵**二叉树**来表示，亦称为**子集树**



![image-20241210134836637](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210134836637.png)

------

![image-20241210134920405](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210134920405.png)



## 旅行商问题——回溯算法

### 问题描述

某商人要到若干城市去推销商品，已知各城市之间的旅行费用，他要选定一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的费用最少。试构造下图对应问题实例的最优旅行方案。

### 回溯算法

**1）问题状态的表示**

$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$ 其中k表示已访问过的城市，$𝑥_𝑖 = \{1,2,3,4\}$表示城市编号，约定第1个城市为驻地，即$𝑋 =[1]$是初始状态。

**2）约束条件**

- $x_i = \{1,2,3,4\}$
- $x_i \ne x_j,$ if  $i \ne j$

**3）操作符**

给定状态$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$，则第k+1个访问城市可以是剩余未访问城市中的任何一个，即$X^`=\{x_1,x_2,....,x_k,x_{k+1}\}$

**4）问题解和解空间**

- 给定{1, 2, 3, 4}的一个**排列**都可以构造一个旅行商路径
- 解空间可以用一棵**多叉树**来表示，亦称为**排列树**

![image-20241210140122111](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210140122111.png)

## 装载问题 **

### 深度优先搜索

时间复杂度：$O(2^n*n):递归O(2^n),叶子节点处理:O(n)$

```c++
算法：loadingDFS
输入：整数 t
输出：最优的装载量
1. if t == n then  // 达到递归的边界条件
2.     sumWeight1 ← 0
3.     for i ← 0 to n - 1 do
4.         sumWeight1 ← sumWeight1 + globalX[i] * globalWeight[i]  // 计算装载量
5.     if sumWeight1 ≤ globalC1 and sumWeight1 > globalAns then
6.         globalAns ← sumWeight1  // 找到更优的可行解
7.     return  // 结束递归
8. if globalX[t] ← 1 then  // 选择装载当前物品
9.     loadingDFS(t + 1)  // 递归扩展左子树
10. globalX[t] ← 0  // 不装载当前物品
11. loadingDFS(t + 1)  // 递归扩展右子树
```

### 回溯算法

****

**1）问题状态的表示**

$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$ 

**2）约束条件**

- $x_i = \{0, 1\}$
- $\sum_{i=1}^k{x_iw_i}≤C$

**3）操作符**

给定状态$𝑋 = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘]$，可能的操作有两种：

- 把第k+1个物品**装入**轮船，有$𝑥_{𝑘+1}=1$；

- 把第k+1个物品**不装入**轮船，有$𝑥_{𝑘+1} = 0$；

得到一个新的状态$𝑋^` = [𝑥_1, 𝑥_2, ⋯ , 𝑥_𝑘,x_{k+1}]$

**4）问题解和解空间**

- 满足约束条件的任何**3维0-1向量**$[𝑥1, 𝑥2, 𝑥3]$都是一个可行解
- 解空间可以用一棵**二叉树**来表示，亦称为**子集树**

时间复杂度:最坏情况$O(2^n)$，最优情况：$O(n)$

```c++
算法：loadingBacktrack
输入：整数 t
输出：最优装载重量
1. if t == n then  // 达到递归的边界条件
2.     globalMaxWt ← globalWt  // 更新最优解
3.     return
4. globalBd ← globalBd - globalWeight[t]  // 扩展子结点时减少 globalBd
5. if globalWt + globalWeight[t] ≤ globalC1 then  // 约束剪枝
6.     globalX[t] ← 1  // 选择装载当前物品
7.     globalWt ← globalWt + globalWeight[t]  // 更新当前装载重量
8.     loadingBacktrack(t + 1)  // 递归扩展左子树
9.     globalWt ← globalWt - globalWeight[t]  // 回溯时恢复 globalWt
10. if globalWt + globalBd > globalMaxWt then  // 限界剪枝
11.     globalX[t] ← 0  // 不装载当前物品
12.     loadingBacktrack(t + 1)  // 递归扩展右子树
13. globalBd ← globalBd + globalWeight[t]  // 回溯时恢复 globalBd
```

### 广度优先搜索

时间复杂度：$O(2^n)$

```c++
Structure node;
    Wt: Int;
    idxBox: Int;

算法：loadingBFS
输入：无
输出：最优装载量
1. maxWt ← 0  // 最优装载量
2. Initialize queue as an empty queue of node  // 初始化队列
3. Create node headNode
4. headNode.Wt ← 0  // 初始装载重量为0
5. headNode.idxBox ← -1  // 初始状态的集装箱编号为 -1
6. Enqueue(headNode, queue)  // 将初始节点加入队列
7. while queue is not empty do
8.     Dequeue(queue) into headNode  // 取出队列首结点
9.     if headNode.idxBox == n then  // 到达叶子结点
10.        if headNode.Wt ≤ globalC1 and headNode.Wt > maxWt then  // 满足约束条件且比当前最优解更优
11.            maxWt ← headNode.Wt  // 更新最优解
12.     else
13.         // 扩展当前结点的所有子结点
14.         sonNode.idxBox ← headNode.idxBox + 1
15.         sonNode.Wt ← headNode.Wt + globalWeight[headNode.idxBox + 1]
16.         Enqueue(sonNode, queue)  // 将左子结点入队
17.         sonNode.Wt ← headNode.Wt  // 右子结点装载重量不增加
18.         Enqueue(sonNode, queue)  // 将右子结点入队
19. return maxWt  // 返回最优装载量
```

### 分支界限法

**剪枝策略**

![image-20241210144710676](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20241210144710676.png)

时间复杂度：最坏情况：$O(2^n)$，剪枝有效情况：接近$O(nlogn)$或$O(n^2)$

```c++
Structure node;
    Wt: Int;
	Bd: Int;
    idxBox: Int;

算法：loadingBranchBound
输入：无
输出：最优装载量
1. maxWt ← 0  // 最优装载量
2. Initialize queue as an empty queue of node  // 初始化队列
3. Create node headNode
4. headNode.Wt ← 0  // 初始装载重量为0
5. headNode.Bd ← n  // 初始剩余集装箱数量
6. headNode.idxBox ← -1  // 初始状态的集装箱编号为 -1
7. Enqueue(headNode, queue)  // 将初始节点加入队列
8. while queue is not empty do
9.     Dequeue(queue) into headNode  // 取出队列首结点
10.    if headNode.idxBox == n then  // 到达叶子结点
11.        if headNode.Wt ≤ globalC1 and headNode.Wt > maxWt then  // 满足约束条件且比当前最优解更优
12.            maxWt ← headNode.Wt  // 更新最优解
13.    else
14.        // 扩展当前结点的所有子结点
15.        // 左子结点: 选择当前集装箱
16.        sonNode.idxBox ← headNode.idxBox + 1
17.        sonNode.Bd ← headNode.Bd - globalWeight[headNode.idxBox + 1]  // 剩余集装箱数量更新
18.        sonNode.Wt ← headNode.Wt + globalWeight[headNode.idxBox + 1]  // 更新装载重量
19.        if sonNode.Wt ≤ globalC1 then  // 约束条件剪枝
20.            Enqueue(sonNode, queue)  // 将左子结点入队
21.            maxWt ← Max(sonNode.Wt, maxWt)  // 更新最优解
22.        // 右子结点: 不选择当前集装箱
23.        sonNode.Wt ← headNode.Wt  // 右子结点装载重量不变
24.        if sonNode.Wt + sonNode.Bd > maxWt then  // 限界条件剪枝
25.            Enqueue(sonNode, queue)  // 将右子结点入队
26. return maxWt  // 返回最优装载量
```

